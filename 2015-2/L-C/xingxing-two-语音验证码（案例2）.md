**目标二：语音验证码控件**  
(并没有找到目前在使用网页播放语音验证码的网站，但是在博客园里找到了一位做过语音验证码控件开发的前辈(brainmao)分享的代码)  
这个语音验证码控件存在的意义是为那些因为视力原因而看不清图片验证码的用户提供方便，也就是作为图片验证码的辅助工具而存在。页面截图如下图：  
![](http://i.imgur.com/UfZxTYF.png)   

用户在难以辨识图中的数字时，可以点击数字图片后喇叭形的按键，通过激活网页中的声音播放器插件来播放语音验证码(onclick="playvoice('player'))。这个控件的工作机制是，在页面加载的时候就同时生成了图形验证码和语音验证码，当用户点击播放键时，便使用嵌入的播放器播放播放生成的MP3文件。显然本次实验的重点并不在于如何在网页上嵌入播放器，而是考虑MP3文件生成和传输过程中的安全性。  
生成MP3文件的代码如下：  
`……
Response.ContentType = "audio/mpeg";  
Response.WriteFile("sound/begin.mp3");  
string checkCode = HttpContext.Current.Request.QueryString ["code"].ToString();  
if (checkCode.Length &gt; 0)
for (int i = 0; i &lt; checkCode.Length; i++)
{  
Response.WriteFile("sound/"+checkCode[i] + ".mp3");  
}  
Response.WriteFile("sound/end.mp3");   
……`
生成MP3文件采用了音频拼接的方法，先确定音频的头部和尾部，之后将传来的验证码字符串逐一从数字对应成声音，然后将生成的声音按顺序拼接起来。 

验证码字符串的生成，以及图形验证码和语音验证码的生成均是在前端页面生成的。先使用随机数产生器产生验证码字符串，然后将生成的验证字符码串通过session传给生成图片和音频的函数，进而生成图片和音频。当用户提交验证请求的时候，验证登陆的脚本就会判断提交的验证码是否与session里的一致。

虽然此处语音验证码的存在使整个网站变得更加的人性化，但因为运行机制过于简单，反而增加了很多不安全的因素：  
1、原本的验证机制就存在问题，只在前端生成和验证验证码，那么很容易就能绕过前端的验证机制，直接和后台服务器建立连接，这样的话验证码的存在本身就没有意义，也就没有必要区分是图片还是语音了；  
2、如果在登录密码错误之后，我们不去访问生成图片验证码和音频验证码的脚本文件，那么session中的验证码如果没有被清空，此时验证码就不会改变，辛辛苦苦构建的防暴力破解就形同虚设了；  
3、使用语音验证码大大降低了验证码的破解难度，因为0~9之间一共也就十个数字，也就只有十种声音轨迹，加上开头和结尾也就十二种，只要将这十二种声音收集下来，将界面的语音验证码进行分析，可以很容易的对比出是哪几个数字，这个效率很明显要比分析图形验证码高的多； 

再和我们第一个目标比较一下，就可以理解为什么找不到一个符合我们需求的案例了，这种在网页上直接语音播放验证码的方式安全性真的太差，暴力破解起来十分容易，并且使原有的图形验证码的作用也变得很低。  
