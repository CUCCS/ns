# geetest（极验）验证方式

### 原理简介

geetest（极验）验证方式属于无知识型验证方式，它最大的特点是不再基于知识进行人机判断，而是基于人类固有的生物特征以及操作的环境信息综合决策，来判断是人类还是机器。无知识型验证码最大特点即无需人类思考，从而不会打断用户操作，进而提供更好的用户体验。它通过简单集成的方式，为开发者提供安全、便捷的云端验证服务。与以往传统验证码不同的是，极验通过分析用户完成拼图过程中的行为特征，通过数据分析来判断是人还是机器。用户不必面对眼花缭乱的英文字符或汉字，整个验证过程变的像游戏一样有趣。
### 验证流程
> 滑动按钮，开始验证 **>** 风险分析 **>** 低风险，校验通过 **/** 高风险，二次验证

首先用户滑动验证码到指定位置，完成后会给服务端回传各种加密信息，为了做风控规则来判断是否异常，其规则会包含用户IP，操作行为路径，UA,COOKIE，设备指纹等等，如果没有命中规则，就会放行校验通过，如果命中规则就会弹出二次校验，只有通过校验后才可以放行。

解释：Web前端采集用户的操作数据，环境数据等等，非常多的数据，通过一个算法加密得到字符串，然后提交到服务器分析，服务器有一个判定标准，对数据进行简单的分析就知道是不是人工在操作。
### 实现原理
滑动验证码最早由淘宝推出。它是根据人在滑动滑块的响应时间，拖拽速度，时间，位置，轨迹，重试次数等来评估风险。

![](http://img.bbs.csdn.net/upload/201703/12/1489306051_404444.jpg)


以下摘自知乎（链接[https://www.zhihu.com/question/37572783](https://www.zhihu.com/question/37572783)）：
> **Step 1：**在Web前端周期性的对Javascript代码进行混淆和并更新加密算法，将不可信的Web前端打造成可信的客户端。在用户进行滑动操作时，基于可信的客户端采集用户操作的行为信息以及环境信息，将其加密后提交给后端的风控引擎；

> Web前端虽然没有客户端防止逆向和调试的安全强度，但是却具备客户端所不具有的hotpatch能力。

> 参考Map-Reduce的原理，单台机器性能不行，把任务分派到多台机器并发执行。如果单份Javascript混淆的强度不可行，那么周期性的对Javascript代码自动混淆。即便攻击者能够短时间的对Web前端进行逆向，但逆向出来的功能短期之后就会在服务端失效，那么也能极大的消耗攻击者的成本。

> 如果代码逻辑不更新，仅仅重复的混淆原有逻辑，那么仍然没有意义。而对于一个Web的验证码应用，核心功能只有两部分：

> 1.事件采集模块，采集用户的行为信息，此部分逻辑简单，也无法自动化更新代码逻辑；

> 2.行为数据加密模块，该部分的核心是加密算法，似乎代码逻辑自动化更新变化有足够空间。

> 为了保障前端的可信，需要对加密算法进行自动化更新，必须要有一个巨大的对称加密算法可选集合才能保证代码的自动化更新。而所有对称加密算法都基于Feistel分组密码结构，基于Feistel分组密码结构可以派生出无数的对称加密算法，从而可以派生出无数的的对称加密算法。

> Festel分组结构的可逆性不要求加密的核心函数F可逆，故可以自动的生成任意的F函数进而派生出无数对称加密算法。基于自动化的代码更新及混淆机制从而保障整个Web代码对抗逆向分析和调试的强度，进而将不可信的Web前端打造成可信的端。

> **Step 2：**后续风控引擎会基于用户操作的行为特征、用户环境信息、用户对应的设备指纹及其设备信誉综合进行决策，判断是否需要对该次操作进行二次判断或者是直接阻断。
### 优点
* 用户体验：

无知识型验证码针对大多数的用户能够无需思考，直接通过。不存在业务和流程的打断，体验流畅，对用户体验的提升毋庸质疑。

* 风险识别：

因为随着机器学习的发展让机器掌握人类具有的知识也不再是难点，无知识型验证码不再基于知识来挑战机器，而是基于人类的固有行为特征以及操作的环境信息综合进行风控决策，攻击者难以批量的模拟出可以欺骗风控引擎的正常人类的的操作。

* 风险拦截：

普通的验证码基于知识对机器发起挑战，无法做到对机器进行阻断。因为知识的挑战还需要兼顾人类的体验，机器通过的概率只能做到无限的降低而无法消除。而无知识型验证码基于后端的风控决策，可以对不同风险的操作提出更高难度的验证码乃至阻断，有更大空间对风险进行消除和拦截。

